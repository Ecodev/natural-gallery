{"version":3,"sources":["webpack://NaturalGallery/webpack/universalModuleDefinition","webpack://NaturalGallery/webpack/bootstrap","webpack://NaturalGallery/./src/js/galleries/AbstractResponsiveRowGallery.ts","webpack://NaturalGallery/./src/js/galleries/AbstractRowGallery.ts","webpack://NaturalGallery/./src/js/galleries/AbstractGallery.ts","webpack://NaturalGallery/./src/js/Utility.ts","webpack://NaturalGallery/./src/index.ts","webpack://NaturalGallery/./src/js/galleries/Natural.ts","webpack://NaturalGallery/external \"PhotoSwipe\"","webpack://NaturalGallery/external \"PhotoSwipeUI_Default\"","webpack://NaturalGallery/./src/js/Item.ts","webpack://NaturalGallery/./src/js/lodash/debounce.js","webpack://NaturalGallery/./src/js/galleries/Masonry.ts","webpack://NaturalGallery/./src/js/Column.ts","webpack://NaturalGallery/./src/js/galleries/ResponsiveSquare.ts","webpack://NaturalGallery/./src/js/galleries/Square.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__7__","__WEBPACK_EXTERNAL_MODULE__8__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","addRows","rows","this","completeLastRow","endResize","flushBufferedItems","visibleCollection","length","lastVisibleRow","row","visibleItemsInLastRow","filter","collectionFromLastVisibleRow","collection","slice","organizeItems","forEach","addItemToDOM","AbstractRowGallery","AbstractResponsiveRowGallery","onScroll","onPageAdd","getRowsPerPage","nbVisibleImages","nextRow","lastWantedRow","bufferedItems","updateNextButtonVisibility","AbstractGallery","elementRef","userOptions","photoswipeElementRef","scrollElementRef","defaultOptions","gap","rowsPerPage","showLabels","lightbox","minRowsAtStart","selectable","activable","infiniteScrollOffset","photoSwipeOptions","cover","photoswipeDefaultOptions","bgOpacity","showHideOpacity","old_scroll_top","_collection","_visibleCollection","photoswipeCollection","scrollBufferedItems","requiredItems","init","classList","add","_","debounce","loadImage","dispatchEvent","model","offset","limit","leading","trailing","defaultsOptions","options","console","error","render","requestItems","bindScroll","document","getEstimatedItemsPerRow","estimation","getEstimatedRowsPerPage","item","destination","bodyElementRef","push","appendChild","element","addEventListener","selected","map","ev","detail","clickEvent","openPhotoSwipe","nextButton","createElement","Utility","getIcon","style","display","e","preventDefault","extendToFreeViewport","iframe","startResize","contentWindow","addItems","models","constructor","Array","Item","getItemOptions","getPhotoswipeItem","minHeight","getGalleryVisibleHeight","documentElement","clientHeight","offsetTop","remove","scrollable","wrapper","Document","startScroll","endScroll","endOfGalleryAt","offsetHeight","current_scroll_top","scrollTop","clientTop","wrapperHeight","scroll_delta","pswpOptions","index","findIndex","loop","assign","photoswipe","PhotoSwipe","PhotoSwipeUI_Default","listen","delta","getCurrentIndex","src","enlargedSrc","w","enlargedWidth","h","enlargedHeight","title","data","event","CustomEvent","selectVisibleItems","select","selectedItems","unselectAllItems","unselect","callback","empty","innerHTML","clear","setItems","items","Math","floor","getBoundingClientRect","width","svg","createElementNS","setAttribute","rowHeight","ceil","fromRow","toRow","currentRow","chunkSize","chunk","getRowWidth","computeSizes","containerWidth","margin","maxRowHeight","getRowHeight","rowWidth","excess","apportionExcess","decimals","getImageRatio","round","height","last","getRatios","totalWidth","el","Number","Natural","_selected","getTitleDetails","term","replace","label","indexOf","image","link","getLinkElement","zoomable","_element","activableEvent","color","backgroundColor","_image","_selectBtn","icon","stopPropagation","toggleSelect","String","marginBottom","marginRight","img","thumbnailSrc","backgroundImage","linkTarget","parentNode","removeChild","_last","_row","_height","_width","isObject","type","func","wait","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","maxing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","startTimer","pendingFunc","setTimeout","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","min","remainingWait","debounced","isInvoking","leadingEdge","max","cancel","clearTimeout","flush","pending","columnWidth","addColumns","addUntilFill","itemsAdded","nbColumns","missingItems","addItemsToDom","estimatedImageHeight","getColumnWidth","currentContainerHeight","counter","nbItems","firstIndex","lastWantedIndex","shortestColumn","getShortestColumn","addItem","columns","columnRef","Column","fromIndex","toIndex","itemsPerRow","lastIndex","reduce","column","Masonry","_elementRef","firstRowIndex","sideSize","getItemSideSize","diff","ResponsiveSquare","Square"],"mappings":"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","file":"natural-gallery.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"PhotoSwipe\"), require(\"PhotoSwipeUI_Default\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"NaturalGallery\", [\"PhotoSwipe\", \"PhotoSwipeUI_Default\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"NaturalGallery\"] = factory(require(\"PhotoSwipe\"), require(\"PhotoSwipeUI_Default\"));\n\telse\n\t\troot[\"NaturalGallery\"] = factory(root[\"PhotoSwipe\"], root[\"PhotoSwipeUI_Default\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__7__, __WEBPACK_EXTERNAL_MODULE__8__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import { AbstractRowGallery } from './AbstractRowGallery';\nimport { GalleryOptions } from './AbstractGallery';\n\nexport interface ResponsiveSquareGalleryOptions extends GalleryOptions {\n    rowHeight: number;\n}\n\nexport abstract class AbstractResponsiveRowGallery extends AbstractRowGallery {\n\n    protected addRows(rows: number): void {\n        this.completeLastRow();\n        super.addRows(rows);\n    }\n\n    protected endResize() {\n        super.endResize();\n        this.completeLastRow();\n        this.flushBufferedItems();\n    }\n\n    private completeLastRow() {\n\n        if (!this.visibleCollection.length) {\n            return;\n        }\n\n        // Get last row number\n        const lastVisibleRow = this.visibleCollection[this.visibleCollection.length - 1].row;\n\n        // Get number of items in that last row\n        const visibleItemsInLastRow = this.visibleCollection.filter(i => i.row === lastVisibleRow).length;\n\n        // Get a list from first item of last row until end of collection\n        const collectionFromLastVisibleRow = this.collection.slice(this.visibleCollection.length - visibleItemsInLastRow);\n        this.organizeItems(collectionFromLastVisibleRow, collectionFromLastVisibleRow[0].row, collectionFromLastVisibleRow[0].row);\n        const itemsToAdd = collectionFromLastVisibleRow.slice(visibleItemsInLastRow)\n                                                       .filter(i => i.row <= collectionFromLastVisibleRow[0].row);\n\n        itemsToAdd.forEach(i => this.addItemToDOM(i));\n    }\n\n}\n","import { AbstractGallery } from './AbstractGallery';\n\nexport abstract class AbstractRowGallery extends AbstractGallery {\n\n    protected onScroll(): void {\n        this.addRows(1);\n    }\n\n    protected onPageAdd(): void {\n        this.addRows(this.getRowsPerPage());\n    }\n\n    /**\n     * Add given number of rows to DOM\n     * @param rows\n     */\n    protected addRows(rows: number): void {\n\n        let nbVisibleImages = this.visibleCollection.length;\n\n        // Next row to add (first invisible row)\n        const nextRow = this.visibleCollection.length ? this.visibleCollection[nbVisibleImages - 1].row + 1 : 0;\n        const lastWantedRow = nextRow + rows - 1;\n\n        // Compute size only for elements we're going to add\n        const bufferedItems = this.collection.slice(nbVisibleImages);\n        this.organizeItems(bufferedItems, nextRow, lastWantedRow);\n        const itemsToAdd = bufferedItems.filter(i => i.row <= lastWantedRow);\n        itemsToAdd.forEach(i => this.addItemToDOM(i));\n\n        this.flushBufferedItems();\n        this.updateNextButtonVisibility();\n    }\n\n    protected endResize() {\n\n        super.endResize();\n\n        if (!this.visibleCollection.length) {\n            return;\n        }\n\n        // Compute with new width. Rows indexes may have change\n        this.organizeItems(this.visibleCollection);\n\n    }\n\n}\n","import * as PhotoSwipe from 'photoswipe';\nimport * as PhotoSwipeUI_Default from 'photoswipe/dist/photoswipe-ui-default';\nimport { Item, ItemOptions } from '../Item';\nimport * as _ from '../lodash/debounce.js';\nimport { Utility } from '../Utility';\n\nexport interface ModelAttributes {\n    thumbnailSrc: string;\n    enlargedSrc?: string;\n    enlargedWidth?: number;\n    enlargedHeight?: number;\n    title?: string;\n    link?: string;\n    linkTarget?: string;\n    color?: string;\n}\n\nexport interface GalleryOptions extends ItemOptions {\n    rowsPerPage?: number;\n    minRowsAtStart?: number;\n    infiniteScrollOffset?: number;\n    photoSwipeOptions?: PhotoSwipeOptions;\n}\n\nexport interface PhotoSwipeOptions {\n    getThumbBoundsFn?: (index?: number) => void;\n    showHideOpacity?: boolean;\n    showAnimationDuration?: number;\n    hideAnimationDuration?: number;\n    bgOpacity?: number;\n    spacing?: number;\n    allowPanToNext?: boolean;\n    maxSpreadZoom?: number;\n    getDoubleTapZoom?: (isMouseClick?: boolean, item?: any) => number;\n    pinchToClose?: boolean;\n    closeOnScroll?: boolean;\n    closeOnVerticalDrag?: boolean;\n    mouseUsed?: boolean;\n    escKey?: boolean;\n    arrowKeys?: boolean;\n    history?: boolean;\n    galleryUID?: number;\n    galleryPIDs?: boolean;\n    errorMsg?: string;\n    preload?: [number, number];\n    mainClass?: string;\n    getNumItemsFn?: () => number;\n    focus?: boolean;\n    modal?: boolean;\n    verticalDragRange?: number;\n    mainScrollEndFriction?: number;\n    panEndFriction?: number;\n    isClickableElement?: (el) => boolean;\n    scaleMode?: string;\n}\n\nexport interface InnerPhotoSwipeOptions extends PhotoSwipeOptions {\n    index: number;\n    loop: boolean;\n}\n\nexport interface PhotoswipeItem {\n    src: string;\n    w: number;\n    h: number;\n    title: string;\n}\n\nexport abstract class AbstractGallery<Model extends ModelAttributes = any> {\n\n    /**\n     * Default options\n     * @private\n     */\n    protected defaultOptions: GalleryOptions = {\n        gap: 3,\n        rowsPerPage: 0,\n        showLabels: 'hover',\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: null,\n        cover: true,\n    };\n\n    protected photoswipeDefaultOptions: PhotoSwipeOptions = {\n        bgOpacity: 0.85,\n        showHideOpacity: false,\n    };\n\n    /**\n     * Final gallery options after having defaulted user given options\n     */\n    protected options: GalleryOptions;\n\n    /**\n     * Used to test the scroll direction\n     * Avoid to load more images when scrolling up\n     */\n    private old_scroll_top = 0;\n\n    /**\n     * Images wrapper container\n     */\n    protected bodyElementRef: HTMLElement;\n\n    /**\n     * Complete collection of images\n     * @type {Array}\n     */\n    protected _collection: Item<Model>[] = [];\n\n    /**\n     * Partial set of items that represent the visible items\n     * @type {Item[]}\n     * @private\n     */\n    protected _visibleCollection: Item<Model>[] = [];\n\n    /**\n     * Photoswipe images container\n     * @type {Array}\n     */\n    private photoswipeCollection: PhotoswipeItem[] = [];\n\n    /**\n     * Reference to next button element\n     */\n    private nextButton: HTMLElement;\n\n    /**\n     * Items for which container has been added to dom, but image has not been queries yet\n     */\n    protected scrollBufferedItems = [];\n\n    /**\n     * Debounced function that queries for images after a little moment where no other images container have been added to DOM\n     */\n    protected flushBufferedItems: () => void;\n\n    protected requiredItems = 0;\n\n    /**\n     *\n     * @param elementRef\n     * @param photoswipeElementRef\n     * @param userOptions\n     * @param scrollElementRef\n     */\n    constructor(protected elementRef: HTMLElement,\n                protected userOptions: GalleryOptions,\n                protected photoswipeElementRef: HTMLElement,\n                protected scrollElementRef: HTMLElement = null) {\n        this.init();\n    }\n\n    protected abstract getEstimatedItemsPerRow(): number;\n\n    protected abstract organizeItems(items: Item[], fromRow?: number, toRow?: number): void;\n\n    protected abstract onScroll(): void;\n\n    protected abstract onPageAdd(): void;\n\n    protected init(): void {\n\n        this.elementRef.classList.add('natural-gallery-js');\n\n        /**\n         * After having finished to add figures to dom, show images inside containers and emit updated pagination\n         */\n        this.flushBufferedItems = _.debounce(() => {\n            this.scrollBufferedItems.forEach(i => {\n                i.loadImage();\n                this.dispatchEvent('item-displayed', i.model);\n            });\n            this.scrollBufferedItems = [];\n\n            if (this.requiredItems) {\n                this.dispatchEvent('pagination', {offset: this.collection.length, limit: this.requiredItems});\n                this.requiredItems = 0;\n            }\n\n        }, 500, {leading: false, trailing: true});\n\n        this.defaultsOptions();\n\n        if (this.options.lightbox && !this.photoswipeElementRef) {\n            console.error('Lightbox option is set to true, but no PhotoSwipe reference is given');\n        }\n\n        this.render();\n        this.requestItems();\n\n        if (!this.options.rowsPerPage) {\n            this.bindScroll(this.scrollElementRef !== null ? this.scrollElementRef : document);\n        }\n    }\n\n    /**\n     * Return number of rows to show per page to fill the empty space until the bottom of the screen\n     * Should grant all the space is used or more, but not less.\n     * @returns {number}\n     */\n    protected abstract getEstimatedRowsPerPage(): number;\n\n    protected defaultsOptions(): void {\n        this.options = this.userOptions || {} as any;\n        for (const key in this.defaultOptions) {\n            if (typeof this.options[key] === 'undefined') {\n                this.options[key] = this.defaultOptions[key];\n            }\n        }\n    }\n\n    /**\n     * Fire pagination event\n     * Information provided in the event allows to retrieve items from the server using given data :\n     * \"offset\" and \"limit\" that have the same semantic that respective attributes in mySQL.\n     *\n     * The gallery asks for items it needs, including some buffer items that are not displayed when given but are available to be added\n     * immediately to DOM when user scrolls.\n     *\n     */\n    protected requestItems() {\n        const estimatedPerRow = this.getEstimatedItemsPerRow();\n        const limit = estimatedPerRow * (this.getRowsPerPage() + 1);\n        this.dispatchEvent('pagination', {offset: this.collection.length, limit: limit});\n    }\n\n    /**\n     * Returns option.rowsPerPage is specified.\n     * If not returns the estimated number of rows to fill the rest of the vertical space in the screen\n     * @returns {number}\n     */\n    protected getRowsPerPage() {\n        if (this.options.rowsPerPage > 0) {\n            return this.options.rowsPerPage;\n        }\n\n        const estimation = this.getEstimatedRowsPerPage();\n        return estimation < this.options.minRowsAtStart ? this.options.minRowsAtStart : estimation;\n    }\n\n    /**\n     * Add given item to DOM and to visibleCollection\n     * @param {Item} item\n     * @param destination\n     */\n    protected addItemToDOM(item: Item<Model>, destination: HTMLElement = this.bodyElementRef): void {\n        this.visibleCollection.push(item);\n        destination.appendChild(item.init());\n        this.scrollBufferedItems.push(item);\n        this.requiredItems++;\n        this.dispatchEvent('item-added-to-dom', item.model);\n\n        // When selected / unselected\n        item.element.addEventListener('select', () => {\n            this.dispatchEvent('select', this.visibleCollection.filter(i => i.selected).map(i => i.model));\n        });\n\n        // When activate (if activate event is given in options)\n        item.element.addEventListener('activate', (ev: CustomEvent) => {\n            this.dispatchEvent('activate', {model: ev.detail.item.model, clickEvent: ev.detail.clickEvent});\n        });\n\n        // When open zoom (photoswipe)\n        item.element.addEventListener('zoom', (ev: CustomEvent) => {\n            this.openPhotoSwipe(ev.detail);\n        });\n\n    }\n\n    protected render() {\n\n        // Next button\n        this.nextButton = document.createElement('div');\n        this.nextButton.classList.add('natural-gallery-next');\n        this.nextButton.appendChild(Utility.getIcon('natural-gallery-icon-next'));\n        this.nextButton.style.display = 'none';\n        this.nextButton.addEventListener('click', (e) => {\n            e.preventDefault();\n            this.onPageAdd();\n        });\n\n        this.bodyElementRef = document.createElement('div');\n        this.bodyElementRef.classList.add('natural-gallery-body');\n        this.extendToFreeViewport();\n\n        // Iframe\n        const iframe = document.createElement('iframe');\n        this.elementRef.appendChild(iframe);\n\n        // Resize debounce\n        const resizeDebounceDuration = 500;\n        const startResize = _.debounce(() => this.startResize(), resizeDebounceDuration, {leading: true, trailing: false});\n        const endResize = _.debounce(() => this.endResize(), resizeDebounceDuration, {leading: false, trailing: true});\n        iframe.contentWindow.addEventListener('resize', () => {\n            endResize();\n            startResize();\n        });\n\n        this.elementRef.appendChild(this.bodyElementRef);\n        this.elementRef.appendChild(this.nextButton);\n    }\n\n    protected updateNextButtonVisibility() {\n        if (this.visibleCollection.length === this.collection.length) {\n            this.nextButton.style.display = 'none';\n        } else {\n            this.nextButton.style.display = 'block';\n        }\n    }\n\n    /**\n     * Add items to collection\n     * Transform given list of models into inner Items\n     * @param models\n     */\n    public addItems(models: Model[]): void {\n\n        if (!(models.constructor === Array && models.length)) {\n            return;\n        }\n\n        // Display newly added images if it's the first addition or if all images are already shown\n        let display = this.collection.length === this.visibleCollection.length;\n\n        // Complete collection\n        models.forEach((model: Model) => {\n            const item = new Item<Model>(this.getItemOptions(), model);\n            this._collection.push(item);\n            this.photoswipeCollection.push(this.getPhotoswipeItem(item));\n        });\n\n        if (display) {\n            this.onPageAdd();\n        }\n    }\n\n    /**\n     * Combine options from gallery with attributes required to generate a figure\n     * @returns {ItemOptions}\n     */\n    private getItemOptions(): ItemOptions {\n        return {\n            lightbox: this.options.lightbox,\n            selectable: this.options.selectable,\n            activable: this.options.activable,\n            gap: this.options.gap,\n            showLabels: this.options.showLabels,\n            cover: this.options.cover,\n        };\n    }\n\n    protected extendToFreeViewport() {\n\n        if (this.options.rowsPerPage) {\n            return this.options.rowsPerPage;\n        }\n\n        this.elementRef.style.minHeight = (this.getGalleryVisibleHeight() + 10) + 'px';\n    }\n\n    /**\n     * Space between the top of the gallery wrapper (parent of gallery root elementRef) and the bottom of the window\n     */\n    protected getGalleryVisibleHeight() {\n        return document.documentElement.clientHeight - this.elementRef.offsetTop;\n    }\n\n    protected startResize() {\n        this.bodyElementRef.classList.add('resizing');\n    }\n\n    protected endResize() {\n        this.bodyElementRef.classList.remove('resizing');\n    }\n\n    /**\n     * Listen to scroll event and manages rows additions for lazy load\n     * @param {HTMLElement | Document} element\n     */\n    private bindScroll(element: HTMLElement | Document) {\n\n        const scrollable = element;\n        let wrapper = null;\n        if (element instanceof Document) {\n            wrapper = element.documentElement;\n        } else {\n            wrapper = element;\n        }\n\n        const startScroll = _.debounce(() => this.elementRef.classList.add('scrolling'), 300, {leading: true, trailing: false});\n        const endScroll = _.debounce(() => this.elementRef.classList.remove('scrolling'), 300, {leading: false, trailing: true});\n\n        scrollable.addEventListener('scroll', () => {\n            startScroll();\n            endScroll();\n            let endOfGalleryAt = this.elementRef.offsetTop + this.elementRef.offsetHeight + this.options.infiniteScrollOffset;\n\n            // Avoid to expand gallery if we are scrolling up\n            let current_scroll_top = wrapper.scrollTop - (wrapper.clientTop || 0);\n            let wrapperHeight = wrapper.clientHeight;\n            let scroll_delta = current_scroll_top - this.old_scroll_top;\n            this.old_scroll_top = current_scroll_top;\n\n            // \"enableMoreLoading\" is a setting coming from the BE bloking / enabling dynamic loading of thumbnail\n            if (scroll_delta > 0 && current_scroll_top + wrapperHeight >= endOfGalleryAt) {\n                // When scrolling only add a row at once\n                this.onScroll();\n            }\n        });\n    }\n\n    protected openPhotoSwipe(item: Item) {\n\n        if (this.options.lightbox && !this.photoswipeElementRef) {\n            console.error('Lightbox option is set to true, but no PhotoSwipe reference is given');\n            return;\n        }\n\n        let pswpOptions: InnerPhotoSwipeOptions = {\n            index: this.collection.findIndex(i => i === item),\n            loop: false,\n        };\n        pswpOptions = Object.assign({}, this.photoswipeDefaultOptions, this.options.photoSwipeOptions, pswpOptions);\n\n        const photoswipe = new PhotoSwipe(this.photoswipeElementRef, PhotoSwipeUI_Default, this.photoswipeCollection, pswpOptions);\n        photoswipe.init();\n\n        // Loading one more page when going to next image\n        photoswipe.listen('beforeChange', (delta) => {\n            // Positive delta means next slide.\n            // If we go next slide, and current index is out of visible collection bound, load more items\n            if (delta === 1 && photoswipe.getCurrentIndex() === this.visibleCollection.length) {\n                this.onPageAdd();\n            }\n        });\n\n        this.dispatchEvent('zoom', {item: item.model, photoswipe: photoswipe});\n    }\n\n    /**\n     * Format an Item into a PhotoswipeItem that has different attributes\n     * @param item\n     * @returns {PhotoswipeItem}\n     */\n    protected getPhotoswipeItem(item): PhotoswipeItem {\n        return {\n            src: item.model.enlargedSrc,\n            w: item.model.enlargedWidth,\n            h: item.model.enlargedHeight,\n            title: item.title,\n        };\n    }\n\n    protected dispatchEvent(name: string, data: any) {\n        const event = new CustomEvent(name, {detail: data});\n        this.elementRef.dispatchEvent(event);\n    }\n\n    /**\n     * Select all items visible in the DOM\n     * Ignores buffered items\n     */\n    public selectVisibleItems(): Model[] {\n        this.visibleCollection.forEach((item) => item.select());\n        return this.selectedItems;\n    }\n\n    /**\n     * Unselect all selected elements\n     */\n    public unselectAllItems() {\n        this.visibleCollection.forEach((item) => item.unselect());\n    }\n\n    /**\n     * Allows to use the same approach and method name to listen as gallery events on DOM or on javascript gallery object\n     *\n     * Gallery requests items when it's instantiated. But user may subscribe after creation, so we need to request again if\n     * user subscribes by this function.\n     *\n     * @param name\n     * @param callback\n     */\n    public addEventListener(name: string, callback: (ev) => void) {\n        this.elementRef.addEventListener(name, callback);\n\n        if (name === 'pagination') {\n            this.requestItems();\n        }\n    }\n\n    /**\n     * Effectively empty gallery, and should prepare container to receive new items\n     */\n    protected empty() {\n        this.bodyElementRef.innerHTML = '';\n        this._visibleCollection = [];\n        this.photoswipeCollection = [];\n        this._collection = [];\n    }\n\n    /**\n     * Public api for empty function\n     * Emits a pagination event\n     */\n    public clear() {\n        this.empty();\n        this.requestItems();\n    }\n\n    /**\n     * Override current collection\n     * @param {Item[]} items\n     */\n    public setItems(items: Model[]) {\n        this.empty();\n        this.addItems(items);\n    }\n\n    get collection(): Item<Model>[] {\n        return this._collection;\n    }\n\n    get visibleCollection(): Item<Model>[] {\n        return this._visibleCollection;\n    }\n\n    get selectedItems(): Model[] {\n        return this.visibleCollection.filter((item) => item.selected).map(item => item.model);\n    }\n\n    get width(): number {\n        return Math.floor(this.bodyElementRef.getBoundingClientRect().width);\n    }\n\n    get collectionLength(): number {\n        return this.collection.length;\n    }\n\n    get visibleCollectionLength(): number {\n        return this.visibleCollection.length;\n    }\n\n}\n","export module Utility {\n\n    export function getIcon(name: string): SVGSVGElement {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('viewBox', '0 0 100 100');\n        svg.innerHTML = '<use xlink:href=\"#' + name + '\"></use>';\n        return svg;\n    }\n\n}\n","import './styles/natural-gallery.scss';\n\nexport * from './js/galleries/Natural';\nexport * from './js/galleries/Masonry';\nexport * from './js/galleries/ResponsiveSquare';\nexport * from './js/galleries/Square';\n","import { Item } from '../Item';\nimport { AbstractResponsiveRowGallery } from './AbstractResponsiveRowGallery';\nimport { GalleryOptions, ModelAttributes } from './AbstractGallery';\n\nexport interface NaturalGalleryOptions extends GalleryOptions {\n    rowHeight: number;\n}\n\nexport class Natural<Model extends ModelAttributes = any> extends AbstractResponsiveRowGallery {\n\n    protected defaultOptions: NaturalGalleryOptions = {\n        rowHeight: 400,\n        gap: 3,\n        rowsPerPage: 0,\n        showLabels: 'hover',\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: null,\n        cover: true\n    };\n\n    protected options: NaturalGalleryOptions;\n\n    protected getEstimatedItemsPerRow(): number {\n        return Math.ceil((this.width + this.options.gap) / (this.options.rowHeight + this.options.gap));\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        return Math.ceil(this.getGalleryVisibleHeight() / (this.options.rowHeight + this.options.gap)) + 1;\n    }\n\n    /**\n     *\n     * @param items\n     * @param fromRow\n     * @param toRow\n     * @param currentRow\n     */\n    protected organizeItems(items: Item[], fromRow: number = 0, toRow: number = null, currentRow: number = null): void {\n\n        if (!currentRow) {\n            currentRow = fromRow ? fromRow : 0;\n        }\n\n        for (let chunkSize = 1; chunkSize <= items.length; chunkSize++) {\n            let chunk = items.slice(0, chunkSize);\n            let rowWidth = this.getRowWidth(this.options.rowHeight, this.options.gap, chunk);\n            if (rowWidth >= this.width) { // if end of row\n                this.computeSizes(chunk, this.width, this.options.gap, currentRow);\n\n                const nextRow = currentRow + 1;\n                if (toRow === null || nextRow <= toRow) {\n                    this.organizeItems(items.slice(chunkSize), fromRow, toRow, nextRow);\n                }\n\n                break;\n            } else if (chunkSize === items.length) {\n                // if end of list\n                // the width is not fixed as we have not enough items\n                // size of images are indexed on max row height.\n                this.computeSizes(chunk, null, this.options.gap, currentRow, this.options.rowHeight);\n                break;\n            }\n        }\n    }\n\n    private computeSizes(chunk: Item[], containerWidth: number, margin: number, row: number, maxRowHeight: number = null): void {\n        let rowHeight = containerWidth ? this.getRowHeight(containerWidth, margin, chunk) : maxRowHeight;\n        let rowWidth = this.getRowWidth(rowHeight, margin, chunk);\n\n        let excess = containerWidth ? this.apportionExcess(chunk, containerWidth, rowWidth) : 0;\n        let decimals = 0;\n\n        for (let i = 0; i < chunk.length; i++) {\n            let item = chunk[i];\n            let width = this.getImageRatio(item) * rowHeight - excess;\n            decimals += width - Math.floor(width);\n            width = Math.floor(width);\n\n            if (decimals >= 1 || i === chunk.length - 1 && Math.round(decimals) === 1) {\n                width++;\n                decimals--;\n            }\n\n            item.width = width;\n            item.height = Math.floor(rowHeight);\n            item.row = row;\n            item.last = i === chunk.length - 1;\n            item.style();\n        }\n    }\n\n    private getRowWidth(maxRowHeight: number, margin: number, items: Item[]): number {\n        return margin * (items.length - 1) + this.getRatios(items) * maxRowHeight;\n    }\n\n    private getRowHeight(containerWidth: number, margin: number, items: Item[]): number {\n        return containerWidth / this.getRatios(items) + margin * (items.length - 1);\n    }\n\n    private getRatios(items: Item[]): number {\n\n        const self = this;\n        let totalWidth = 0;\n\n        for (let i = 0; i < items.length; i++) {\n            totalWidth += self.getImageRatio(items[i]);\n        }\n\n        return totalWidth;\n    }\n\n    private getImageRatio(el: Item): number {\n        return Number(el.enlargedWidth) / Number(el.enlargedHeight);\n    }\n\n    private apportionExcess(items: Item[], containerWidth: number, rowWidth: number): number {\n        let excess = rowWidth - containerWidth;\n        return excess / items.length;\n    }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","import { Utility } from './Utility';\nimport { ModelAttributes } from './galleries/AbstractGallery';\n\nexport declare interface ItemOptions {\n    lightbox?: boolean;\n    selectable?: boolean;\n    activable?: boolean;\n    gap?: number;\n    showLabels?: 'hover' | 'never' | 'always';\n    cover?: boolean;\n}\n\nexport interface ItemTitle {\n    title: string;\n    link: string;\n    linkTarget: '_blank' | '_self' | '_parent' | '_top';\n}\n\nexport class Item<Model extends ModelAttributes = any> {\n\n    /**\n     * Cleaned title, used for label / button\n     */\n    private readonly title: string;\n\n    /**\n     * Actual row index in the list\n     */\n    private _row: number;\n\n    /**\n     * If is actually the last element of a row\n     */\n    private _last: boolean;\n\n    /**\n     * Computed size (real used size)\n     */\n    private _width: number;\n    private _height: number;\n\n    /**\n     * Wherever item is selected or not\n     * @type {boolean}\n     * @private\n     */\n    private _selected = false;\n\n    /**\n     * Item root element reference (figure)\n     */\n    private _element: HTMLElement;\n\n    /**\n     * Image container reference (child div, containing the image)\n     */\n    private _image: HTMLElement;\n\n    /**\n     * Reference to the select button\n     */\n    private _selectBtn: HTMLElement;\n\n    /**\n     *\n     * @param {ItemOptions} options\n     * @param model Contains the source data given for an item (e.g object instance from database with id etc..)\n     */\n    public constructor(private readonly options: ItemOptions, public readonly model: Model) {\n        this.title = this.getTitleDetails(model.title);\n    }\n\n    /**\n     * Cleans html, and returns only the texte from all eventual tags\n     * @param {string} term\n     * @returns {ItemTitle}\n     */\n    private getTitleDetails(term: string): string {\n        return term.replace(/<(?!\\s*br\\s*\\/?)[^>]+>/gi, '');\n    }\n\n    /**\n     * Create DOM elements according to element raw data (thumbnail and enlarged urls)\n     * Also apply border-radius at this level because it never changed threw time\n     */\n    public init() {\n\n        let label = null;\n\n        // Test if label should be added to dom\n        const showLabelValues = ['always', 'hover'];\n        if (this.title && showLabelValues.indexOf(this.options.showLabels) > -1) {\n            label = true;\n        }\n\n        let element = document.createElement('div') as HTMLElement;\n        let image = document.createElement('div') as HTMLElement;\n        let link = this.getLinkElement();\n        let zoomable: HTMLElement = null;\n\n        // Activation is listened on label/button or on whole image if lightbox is off.\n        // If label is not a button, it becomes a button\n        let activable: HTMLElement = null;\n\n        if (this.options.lightbox && label && link) {\n            label = link;\n            label.classList.add('button');\n            zoomable = image;\n            activable = link;\n\n        } else if (this.options.lightbox && label && !link) {\n            label = document.createElement('div');\n\n            if (this.options.activable) {\n                activable = label;\n                label.classList.add('button');\n                zoomable = image;\n            } else {\n                zoomable = element;\n            }\n\n        } else if (this.options.lightbox && !label) {\n            // Actually, lightbox has priority on the link that is ignored...\n            zoomable = element;\n\n            // May be dangerous to consider image as activation, because opening the lightbox is already an action and we could have two...\n            // It's ok if activate event is used for tracking, but not if it's used to do an action.\n            // In the doubt, for now it's not allowed\n            // activable = element;\n\n        } else if (!this.options.lightbox && label && link) {\n            image = this.getLinkElement();\n            label = link;\n            label.classList.add('button');\n            activable = element;\n\n        } else if (!this.options.lightbox && label && !link) {\n            label = document.createElement('div');\n            if (this.options.activable) {\n                activable = element;\n                label.classList.add('button');\n            }\n\n        } else if (!this.options.lightbox && !label && link) {\n            image = link;\n            activable = link;\n        }\n\n        if (zoomable) {\n            zoomable.classList.add('zoomable');\n\n            zoomable.addEventListener('click', () => {\n                const event = new CustomEvent('zoom', {detail: this});\n                this._element.dispatchEvent(event);\n            });\n        }\n\n        if (activable) {\n            activable.classList.add('activable');\n            activable.addEventListener('click', (ev) => {\n                const data = {\n                    item: this,\n                    clickEvent: ev,\n                };\n                const activableEvent = new CustomEvent('activate', {detail: data});\n                this._element.dispatchEvent(activableEvent);\n            });\n        }\n\n        if (this.options.cover) {\n            image.classList.add('cover');\n        }\n\n        image.classList.add('image');\n        element.classList.add('figure');\n        element.appendChild(image);\n\n        if (this.model.color) {\n            element.style.backgroundColor = this.model.color + '11';\n        }\n\n        this._element = element;\n        this._image = image;\n\n        if (label) {\n            label.innerHTML = this.title;\n            label.classList.add('title');\n            if (this.options.showLabels === 'hover') {\n                label.classList.add('hover');\n            }\n            element.appendChild(label);\n        }\n\n        if (this.options.selectable) {\n            this._selectBtn = document.createElement('div');\n            const icon = Utility.getIcon('natural-gallery-icon-select');\n            this._selectBtn.appendChild(icon);\n            this._selectBtn.classList.add('selectBtn');\n            this._selectBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.toggleSelect();\n                const event = new CustomEvent('select', {detail: this});\n                this._element.dispatchEvent(event);\n            });\n            this._element.appendChild(this._selectBtn);\n        }\n\n        this.style();\n\n        return element;\n    }\n\n    /**\n     * Use computed (organized) data to apply style (size and margin) to elements on DOM\n     * Does not apply border-radius because is used to restyle data on browser resize, and border-radius don't change.\n     */\n    public style() {\n\n        if (!this._element) {\n            return;\n        }\n\n        this._element.style.width = String(this.width + 'px');\n        this._element.style.height = String(this.height + 'px');\n        this._element.style.marginBottom = String(this.options.gap + 'px');\n\n        if (this.last) {\n            this._element.style.marginRight = '0';\n        } else {\n            this._element.style.marginRight = String(this.options.gap + 'px');\n        }\n    }\n\n    /**\n     * This function prepare loaded/loading status and return root element.\n     * @returns {HTMLElement}\n     */\n    public loadImage() {\n\n        let img = document.createElement('img');\n        img.setAttribute('src', this.model.thumbnailSrc);\n\n        this._image.style.backgroundImage = 'url(' + this.model.thumbnailSrc + ')';\n\n        img.addEventListener('load', () => {\n            this._element.classList.add('loaded');\n        });\n\n        // Detect errored images and hide them smartly\n        img.addEventListener('error', () => {\n            this._element.classList.add('errored');\n        });\n    }\n\n    public toggleSelect() {\n        if (this._selected) {\n            this.unselect();\n        } else {\n            this.select();\n        }\n    }\n\n    public select() {\n        this._selected = true;\n        this._element.classList.add('selected');\n    }\n\n    public unselect() {\n        this._selected = false;\n        this._element.classList.remove('selected');\n    }\n\n    private getLinkElement(): HTMLElement {\n\n        if (this.model.link) {\n            let link = document.createElement('a');\n            link.setAttribute('href', this.model.link);\n            link.classList.add('link');\n            if (this.model.linkTarget) {\n                link.setAttribute('target', this.model.linkTarget);\n            }\n\n            return link;\n        }\n\n        return null;\n    }\n\n    public remove() {\n        if (this._element.parentNode) {\n            this._element.parentNode.removeChild(this._element);\n        }\n    }\n\n    get last(): boolean {\n        return this._last;\n    }\n\n    set last(value: boolean) {\n        this._last = value;\n    }\n\n    get row(): number {\n        return this._row;\n    }\n\n    set row(value: number) {\n        this._row = value;\n    }\n\n    get height(): number {\n        return this._height;\n    }\n\n    set height(value: number) {\n        this._height = value;\n    }\n\n    get width(): number {\n        return this._width;\n    }\n\n    set width(value: number) {\n        this._width = value;\n    }\n\n    get enlargedWidth(): number {\n        return this.model.enlargedWidth;\n    }\n\n    get enlargedHeight(): number {\n        return this.model.enlargedHeight;\n    }\n\n    get selected(): boolean {\n        return this._selected;\n    }\n\n    get element(): HTMLElement {\n        return this._element;\n    }\n\n}\n","export function isObject(value) {\n    const type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n}\n\nexport function debounce(func, wait, options) {\n    let lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime;\n\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n\n    if (typeof func != 'function') {\n        throw new TypeError('Expected a function');\n    }\n\n    wait = +wait || 0;\n    if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n\n    function startTimer(pendingFunc, wait) {\n        return setTimeout(pendingFunc, wait);\n    }\n\n    function cancelTimer(id) {\n        clearTimeout(id);\n    }\n\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = startTimer(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n                (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n\n    function pending() {\n        return timerId !== undefined;\n    }\n\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\n","import { AbstractGallery, GalleryOptions, ModelAttributes } from './AbstractGallery';\nimport { Item } from '../Item';\nimport { Column } from '../Column';\n\nexport interface MasonryGalleryOptions extends GalleryOptions {\n    columnWidth: number;\n}\n\nexport class Masonry<Model extends ModelAttributes = any> extends AbstractGallery {\n\n    protected defaultOptions: MasonryGalleryOptions = {\n        columnWidth: 300,\n        gap: 3,\n        rowsPerPage: 0,\n        showLabels: 'hover',\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: null,\n        cover: true\n    };\n\n    protected options: MasonryGalleryOptions;\n\n    protected columns: Column[];\n\n    protected init(): void {\n        super.init();\n        this.addColumns();\n    }\n\n    protected onScroll(): void {\n        this.addUntilFill();\n    }\n\n    protected onPageAdd(): void {\n        const itemsAdded = this.addUntilFill();\n        const nbColumns = this.getEstimatedItemsPerRow();\n        const itemsPerPage = this.getEstimatedRowsPerPage() * nbColumns;\n        const missingItems = itemsPerPage - itemsAdded;\n\n        if (missingItems > 0) {\n            this.addItemsToDom(missingItems);\n        }\n    }\n\n    /**\n     * Returns here the number of columns\n     */\n    protected getEstimatedItemsPerRow(): number {\n        return Math.ceil((this.width - this.options.gap) / (this.options.columnWidth + this.options.gap));\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        const ratio = 1.75; // landscape format to estimate the maximum number of rows\n        const columnWidth = this.getColumnWidth();\n        const estimatedImageHeight = columnWidth / ratio;\n        return Math.ceil(this.getGalleryVisibleHeight() / estimatedImageHeight);\n    }\n\n    /**\n     * Use current gallery height as reference. To fill free space it add images until the gallery height changes, then are one more row\n     */\n    protected addUntilFill(): number {\n        const currentContainerHeight = this.elementRef.clientHeight;\n        let counter = 0;\n\n        do {\n            counter++;\n            this.addItemsToDom(1);\n        } while (this.elementRef.clientHeight === currentContainerHeight && this.visibleCollection.length < this.collection.length);\n\n        const rowsPerPage = this.getEstimatedRowsPerPage();\n        this.addItemsToDom(rowsPerPage);\n        return counter + rowsPerPage;\n    }\n\n    private addItemsToDom(nbItems) {\n\n        let nbVisibleImages = this.visibleCollection.length;\n\n        // Next row to add (first invisible row)\n        const firstIndex = this.visibleCollection.length ? nbVisibleImages : 0;\n        const lastWantedIndex = firstIndex + nbItems - 1;\n\n        // Compute size only for elements we're going to add\n        this.organizeItems(this.collection.slice(nbVisibleImages), firstIndex, lastWantedIndex);\n\n        for (let i = nbVisibleImages; i < this.collection.length; i++) {\n            let item = this.collection[i];\n            if (i <= lastWantedIndex) {\n                this.addItemToDOM(item);\n            } else {\n                break;\n            }\n        }\n\n        this.flushBufferedItems();\n        this.updateNextButtonVisibility();\n    }\n\n    protected addItemToDOM(item: Item<Model>, destination: HTMLElement = null): void {\n        const shortestColumn = this.getShortestColumn();\n        shortestColumn.addItem(item);\n        super.addItemToDOM(item, shortestColumn.elementRef);\n    }\n\n    protected endResize() {\n\n        super.endResize();\n\n        if (!this.visibleCollection.length) {\n            return;\n        }\n\n        // Compute with new width. Rows indexes may have change\n        this.visibleCollection.length = 0;\n        this.addColumns();\n        this.addUntilFill();\n    }\n\n    protected addColumns() {\n        this.bodyElementRef.innerHTML = '';\n        this.columns = [];\n        const columnWidth = this.getColumnWidth();\n        for (let i = 0; i < this.getEstimatedItemsPerRow(); i++) {\n            const columnRef = new Column({width: columnWidth, gap: this.options.gap});\n            this.columns.push(columnRef);\n            this.bodyElementRef.appendChild(columnRef.init());\n        }\n    }\n\n    /**\n     * Compute sides with 1:1 ratio\n     * @param items\n     * @param fromIndex\n     * @param toIndex\n     */\n    protected organizeItems(items: Item[], fromIndex: number = 0, toIndex: number = null): void {\n\n        let itemsPerRow = this.getEstimatedItemsPerRow();\n\n        // Compute columnWidth of pictures\n        let columnWidth = this.getColumnWidth();\n\n        let lastIndex = toIndex ? itemsPerRow * (toIndex - fromIndex + 1) : items.length;\n        lastIndex = lastIndex > items.length ? items.length : lastIndex;\n\n        for (let i = 0; i < lastIndex; i++) {\n            const item = items[i];\n            item.last = true;\n            item.width = Math.floor(columnWidth);\n            item.height = item.width * item.model.enlargedHeight / item.model.enlargedWidth;\n            item.style();\n        }\n    }\n\n    /**\n     * Return square side size\n     */\n    private getColumnWidth(): number {\n        const itemsPerRow = this.getEstimatedItemsPerRow();\n        return Math.floor((this.width - (itemsPerRow - 1) * this.options.gap) / itemsPerRow);\n    }\n\n    private getShortestColumn() {\n        return this.columns.reduce((shortestColumn, column) => {\n            if (!shortestColumn) {\n                return column;\n            }\n\n            return column.height < shortestColumn.height ? column : shortestColumn;\n        });\n    }\n\n    protected empty() {\n        super.empty();\n        this.addColumns();\n    }\n\n}\n","import { Item } from './Item';\n\nexport declare interface ColumnOptions {\n    width: number;\n    gap: number;\n}\n\nexport class Column {\n\n    private collection: Item[] = [];\n\n    private _elementRef: HTMLElement;\n\n    public constructor(private options: ColumnOptions) {\n    }\n\n    public init() {\n        this._elementRef = document.createElement('div');\n        this._elementRef.classList.add('column');\n        this._elementRef.style.marginRight = this.options.gap + 'px';\n        this._elementRef.style.width = this.options.width + 'px';\n        return this._elementRef;\n    }\n\n    public addItem(item: Item) {\n        this.collection.push(item);\n    }\n\n    get height(): number {\n        return this._elementRef.offsetHeight;\n    }\n\n    get length(): number {\n        return this.collection.length;\n    }\n\n    get elementRef(): HTMLElement {\n        return this._elementRef;\n    }\n\n}\n","import { Item } from '../Item';\nimport { AbstractResponsiveRowGallery, ResponsiveSquareGalleryOptions } from './AbstractResponsiveRowGallery';\nimport { ModelAttributes } from './AbstractGallery';\n\nexport class ResponsiveSquare<Model extends ModelAttributes = any> extends AbstractResponsiveRowGallery {\n\n    protected defaultOptions: ResponsiveSquareGalleryOptions = {\n        rowHeight: 400,\n        gap: 3,\n        rowsPerPage: 0,\n        showLabels: 'hover',\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: null,\n        cover: true\n    };\n\n    protected options: ResponsiveSquareGalleryOptions;\n\n    protected getEstimatedItemsPerRow(): number {\n        return Math.ceil((this.width + this.options.gap) / (this.options.rowHeight + this.options.gap));\n    }\n\n    /**\n     * Compute sides with 1:1 ratio\n     * @param items\n     * @param firstRowIndex\n     * @param toRow\n     */\n    protected organizeItems(items: Item[], firstRowIndex: number = 0, toRow: number = null): void {\n\n        let itemsPerRow = this.getEstimatedItemsPerRow();\n\n        // Compute sideSize of pictures\n        let sideSize = this.getItemSideSize();\n\n        // Compute overflow of given images per row. This number affect the width of the last item of the row\n        let diff = this.width - itemsPerRow * sideSize - (itemsPerRow - 1) * this.options.gap;\n\n        let lastIndex = toRow ? itemsPerRow * (toRow - firstRowIndex + 1) : items.length;\n        lastIndex = lastIndex > items.length ? items.length : lastIndex;\n\n        for (let i = 0; i < lastIndex; i++) {\n            const item = items[i];\n            item.last = i % itemsPerRow === itemsPerRow - 1;\n            item.row = Math.floor(i / itemsPerRow) + firstRowIndex;\n            item.width = Math.floor(sideSize);\n            item.height = Math.floor(sideSize);\n            if (item.last) {\n                item.width = Math.floor(sideSize + diff);\n            }\n            item.style();\n        }\n    }\n\n    protected getItemSideSize(): number {\n        const itemsPerRow = this.getEstimatedItemsPerRow();\n        return (this.width - (itemsPerRow - 1) * this.options.gap) / itemsPerRow;\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        return Math.ceil(this.getGalleryVisibleHeight() / this.getItemSideSize());\n    }\n\n}\n","import { Item } from '../Item';\nimport { AbstractRowGallery } from './AbstractRowGallery';\nimport { GalleryOptions, ModelAttributes } from './AbstractGallery';\n\nexport interface SquareGalleryOptions extends GalleryOptions {\n    itemsPerRow: number;\n}\n\nexport class Square<Model extends ModelAttributes = any> extends AbstractRowGallery {\n\n    protected defaultOptions: SquareGalleryOptions = {\n        itemsPerRow: 4,\n        gap: 3,\n        rowsPerPage: 0,\n        showLabels: 'hover',\n        lightbox: false,\n        minRowsAtStart: 2,\n        selectable: false,\n        activable: false,\n        infiniteScrollOffset: 0,\n        photoSwipeOptions: null,\n        cover: true,\n    };\n\n    protected options: SquareGalleryOptions;\n\n    protected getEstimatedItemsPerRow() {\n        return this.options.itemsPerRow;\n    }\n\n    /**\n     * Compute sides with 1:1 ratio\n     * @param items\n     * @param firstRowIndex\n     * @param toRow\n     */\n    protected organizeItems(items: Item[], firstRowIndex: number = 0, toRow: number = null): void {\n\n        let sideSize = this.getItemSideSize();\n        let lastIndex = toRow ? this.options.itemsPerRow * (toRow - firstRowIndex + 1) : items.length;\n        lastIndex = lastIndex > items.length ? items.length : lastIndex;\n\n        for (let i = 0; i < lastIndex; i++) {\n            let item = items[i];\n            item.width = Math.floor(sideSize);\n            item.height = Math.floor(sideSize);\n            item.last = i % this.options.itemsPerRow === this.options.itemsPerRow - 1;\n            item.row = Math.floor(i / this.options.itemsPerRow) + firstRowIndex;\n            item.style();\n        }\n    }\n\n    protected getEstimatedRowsPerPage(): number {\n        return Math.ceil(this.getGalleryVisibleHeight() / this.getItemSideSize());\n    }\n\n    /**\n     * Return square side size\n     */\n    protected getItemSideSize(): number {\n        const itemsPerRow = this.getEstimatedItemsPerRow();\n        return (this.width - (itemsPerRow - 1) * this.options.gap) / itemsPerRow;\n    }\n\n}\n"],"sourceRoot":""}